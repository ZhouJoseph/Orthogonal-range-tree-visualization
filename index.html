<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orthogonal Range Tree Demo</title>
    <!-- d3.js for data visualization purposes -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- bootstrap CSS-->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css"
    />
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <!-- Add a svg shape -->
    <section class="hero is-light">
      <div class="hero-body">
        <div>
          <p class="is-size-4"><b>What is this?</b></p>
          <p class="is-size-6">
            It's my personal project:
            <b>2D Orthogonal Range Tree Visualization</b>. <br />
            - <b><i>The plane canvas:</i></b> is the canvas which holds the
            points that we are working with.
            <br />
            - <b><i>The tree canvas:</i></b> displays the orthogonal range tree
            generataed from the points in the plane canvas.
          </p>
          <br />
          <p class="is-size-4"><b>How to use it?</b></p>
          <p class="is-size-6">
            <b>1. point inialization:</b><br />
            - You can enter your own points by clicking on the plane canvas.
            <br />
            - Or you can initialize them randomly by clicking the [random points
            generation] button. <br />
            <b>2. range tree creation:</b><br />
            - Once you create your points, you can click the [Build Range Tree]
            button <br />
            <b>3. search:</b><br />
            - Once you built your range tree, you can click the [Find Points in
            Range] button
          </p>
          <br />
          <p class="is-size-4"><b>Terminologies</b></p>
          <p class="is-size-6">
            <b>S:</b> Split nodes <b>WR:</b> Within Range <b>RS:</b> Report
            entire Subtree as found points <b>lightblue nodes:</b> Where we need
            to do a search in the assoc structure
          </p>
        </div>
      </div>
    </section>
    <center>
      <div id="planediv">
        <div class="container">
          <p class="is-size-4">Plane canvas</p>
        </div>

        <div id="svgWrapper">
          <svg id="plane"></svg>
          <fieldset id="controls">
            <label>x:<input type="text" id="x" value="150" /></label>
            <label>y:<input type="text" id="y" value="150" /></label>
            <label>width:<input type="text" id="width" value="400" /></label>
            <label>height:<input type="text" id="height" value="400" /></label>
          </fieldset>
        </div>
        <button
          id="buildTree"
          class="button is-info is-light"
          onclick="buildTree()"
          disabled
        >
          Build Range Tree
        </button>
        <button
          id="findPoints"
          class="button is-info is-light"
          onclick="findPoints()"
          disabled
        >
          Find Points in Range
        </button>
        <button
          id="randomizedPoint"
          class="button is-info is-light"
          onclick="randomized()"
        >
          Randomized 8 Points
        </button>
        <button
          id="randomizedQuery"
          class="button is-info is-light"
          onclick="randomizedQuery()"
        >
          Randomized Query
        </button>
      </div>
    </center>
    <div id="treediv">
      <center>
        <div class="container">
          <p class="is-size-4">Tree Canvas</p>
        </div>
      </center>
      <svg id="tree"></svg>
    </div>
    <!-- bootstrap js -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
      crossorigin="anonymous"
    ></script>

    <script
      src="https://code.jquery.com/jquery-3.6.0.slim.js"
      integrity="sha256-HwWONEZrpuoh951cQD1ov2HUK5zA5DwJ1DNUXaM6FsY="
      crossorigin="anonymous"
    ></script>
  </body>
  <script>
    // setup & initilize
    var userInputRange = {};
    var inpX = document.getElementById("x");
    var inpY = document.getElementById("y");
    var inpWidth = document.getElementById("width");
    var inpHeight = document.getElementById("height");

    [inpX, inpY, inpWidth, inpHeight].forEach(function (e) {
      e.addEventListener("change", updateUserInputRange);
    });

    var planeSVG = d3.select("#plane");
    var treeSVG = d3.select("#tree");

    function updateUserInputRange() {
      userInputRange = {
        xleft: parseFloat(inpX.value),
        xright: parseFloat(inpX.value) + parseFloat(inpWidth.value),
        ytop: parseFloat(inpY.value) + parseFloat(inpHeight.value),
        ybottom: parseFloat(inpY.value),
      };
      planeSVG.selectAll("rect").remove();
      planeSVG
        .append("rect")
        .attr("x", parseFloat(inpX.value))
        .attr("y", parseFloat(inpY.value))
        .attr("width", parseFloat(inpWidth.value))
        .attr("height", parseFloat(inpHeight.value))
        .attr("stroke", "#2f2f2f")
        .attr("fill", "#ffffff50");
    }
    var planeWidth = $("#plane").width();
    var planeHeight = $("#plane").height();
    var rangeWidth = 200;
    function updateUserInput(x, y, width, height) {
      $("#x").val(x.toString());
      $("#y").val(y.toString());
      $("#width").val(width.toString());
      $("#height").val(height.toString());
    }
    updateUserInput(
      planeWidth / 2 - rangeWidth / 2,
      planeHeight / 2 - rangeWidth / 2,
      rangeWidth,
      rangeWidth
    );
    updateUserInputRange();

    // globals for explaination
    var numMessage = 0;
    var startingMessageX = 10;
    var startingMessageY = 20;
    var messageRange = 20;

    // points are stored in dps -> data points;
    var dps = [];
    // to refresh the color of the points (to notify that point is in range, it's highlighted)
    function refreshSvg() {
      updateUserInputRange();
      var temp = [];
      planeSVG.selectAll("g").data(temp).exit().remove();
      addPointToPlane(0, 0, false);
    }
    // to refresh the tree (exit and then remove)
    function refreshTree() {
      treeData = [];
      treeBranch = [];
      numMessage = 0;
      treeSVG.selectAll("text").data([]).exit().remove();
      treeSVG.selectAll("g").data(treeData).exit().remove();
      treeSVG.selectAll("line").data(treeBranch).exit().remove();
    }

    function addPointToPlane(x, y, push = true) {
      if (push) {
        console.log("clicked:", x, y);
        if (dps.length != 0) {
          document.getElementById("buildTree").disabled = false;
        }
        var leafkey = x + ";" + y;
        var id = 0;
        if (leafkey in leafNodeID) {
          id = leafNodeID[leafkey];
        } else {
          id = leafIDCounter--;
          leafNodeID[leafkey] = id;
        }
        dps.push([x, y, "#2f2f2f", id + "leaf"]);
      }

      var dots = planeSVG.selectAll("g").data(dps).enter().append("g");

      dots
        .append("circle")
        .attr("class", function (dp) {
          return dp[3] + " hovercursor";
        })
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];

          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];

          $(id).attr("r", "5");
        })
        .attr("cx", function (dp) {
          return dp[0];
        })
        .attr("cy", function (dp) {
          return dp[1];
        })
        .attr("r", 5)
        .style("fill", function (dp) {
          return dp[2];
        });
      dots
        .append("text")
        .attr("class", function (dp) {
          return dp[3] + " hovercursor";
        })
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];

          $(id).attr("r", "5");
        })
        .attr("dx", function (dp) {
          return dp[0] + 5;
        })
        .attr("dy", function (dp) {
          return dp[1] - 5;
        })
        .text(function (dp) {
          return dp[0].toString() + "," + dp[1].toString();
        })
        .style("fill", function (dp) {
          return dp[2];
        });
    }

    // store the clicked points
    planeSVG.on("click", function (e) {
      if (dps.length >= 16) {
        alert("for better display, at most16 points are allowed.");
        return;
      }
      var position = d3.pointer(e);
      var x = position[0];
      var y = position[1];
      addPointToPlane(x, y);
    });

    var leafNodeID = {};
    var treeNodeID = 0;
    var leafIDCounter = -1;
    // followed are the rangeTree Algorithm
    function createNode(
      isleaf,
      val,
      left = null,
      right = null,
      assoc = null,
      parent = null,
      x = null,
      y = null
    ) {
      var id = -1;
      var leafID = null;
      if (isleaf) {
        var leafkey = val[0] + ";" + val[1];
        if (leafkey in leafNodeID) {
          leafID = leafNodeID[leafkey];
        } else {
          leafID = leafIDCounter--;
          leafNodeID[leafkey] = leafID;
        }
      }
      id = treeNodeID++;
      return {
        val: val,
        left: left,
        right: right,
        assoc: assoc,
        isleaf: isleaf,
        parent: parent,
        id: id,
        leafID: leafID,
      };
    }

    function splitInHalf(p, alignment = true) {
      if (alignment) {
        p.sort(function (a, b) {
          return a[0] - b[0];
        });
      } else {
        p.sort(function (a, b) {
          return a[1] - b[1];
        });
      }
      var mid = Math.ceil(p.length / 2);
      var leftHalf = p.slice(0, mid);
      var rightHalf = p.slice(mid, p.length);
      var result = {
        mid: mid - 1,
        leftHalf: leftHalf,
        rightHalf: rightHalf,
      };
      return result;
    }

    function build2DRangeTree(p, alignment = true, parent = null) {
      if (p.length === 1) {
        var node = createNode(true, p[0]);
        node.parent = parent;
        return node;
      } else {
        var result = splitInHalf(p, alignment);
        var node = createNode(
          false,
          alignment ? p[result.mid][0] : p[result.mid][1]
        );
        var leftNode = build2DRangeTree(result.leftHalf, alignment, node);
        var rightNode = build2DRangeTree(result.rightHalf, alignment, node);
        node.left = leftNode;
        node.right = rightNode;
        node.assoc = alignment ? build2DRangeTree(p, false) : null;
        node.parent = parent;
        return node;
      }
    }

    function drawVisiting(node, alignment, range) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var p = node;
      var smaller = 0;
      var bigger = 0;
      if (alignment) {
        smaller = xl;
        bigger = xr;
      } else {
        smaller = yb;
        bigger = yt;
      }
      var messageNumber = numMessage++;
      var isSplit = false;
      if (p.isleaf) {
        if (alignment) {
          if (smaller <= p.val[0] && bigger >= p.val[0]) {
            isSplit = true;
          }
        } else {
          if (smaller <= p.val[1] && bigger >= p.val[1]) {
            isSplit = true;
          }
        }
      } else {
        if (smaller <= p.val && bigger >= p.val) {
          isSplit = true;
        }
      }
      var directionToGo = "";
      if (!node.isleaf && !isSplit) {
        if (bigger <= node.val) {
          directionToGo +=
            bigger.toString() +
            " <= " +
            node.val.toString() +
            ", try visiting its left child";
        } else {
          directionToGo +=
            bigger.toString() +
            " > " +
            node.val.toString() +
            ", try visiting its right child";
        }
      }
      var text =
        "Step " +
        messageNumber.toString() +
        ". Visiting node: " +
        (node.isleaf ? node.val[0] + "," + node.val[1] : node.val) +
        "..." +
        directionToGo;

      text += isSplit ? "found! Should start visiting both left and right" : "";
      treeSVG
        .append("text")
        .attr("class", node.id + "node " + node.id + "explain")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "5");
        })
        .style("fill", "#fdfdfd");
    }
    function drawS(node, alignment, range) {
      treeSVG
        .append("text")
        .attr("dx", node.x - 5)
        .attr("dy", node.y - 10)
        .text("S")
        .style("fill", "pink");
    }

    function drawFindSplit(range, alignment) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var smaller = 0;
      var bigger = 0;
      if (alignment) {
        smaller = xl;
        bigger = xr;
      } else {
        smaller = yb;
        bigger = yt;
      }

      var messageNumber = numMessage++;
      var text =
        "Step " +
        messageNumber.toString() +
        ". Looking for a " +
        (alignment ? "horizontal" : "vertial") +
        " split node within the range [" +
        smaller +
        "," +
        bigger +
        "]";
      treeSVG
        .append("text")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .style("fill", "#fdfdfd");
    }

    function drawNotFindSplit() {
      var messageNumber = numMessage++;
      var text =
        "Step " + messageNumber.toString() + ". Didn't find any split node...";
      treeSVG
        .append("text")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .style("fill", "#fdfdfd");
    }

    // due to degeneracy, split node needs to be more generous
    async function findSplitNode(node, range, alignment = true, draw = true) {
      if (draw) {
        drawFindSplit(range, alignment);
      }

      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var p = node;
      var smaller = 0;
      var bigger = 0;
      if (alignment) {
        smaller = xl;
        bigger = xr;
      } else {
        smaller = yb;
        bigger = yt;
      }
      while (p !== null) {
        if (draw) {
          var id = "." + p.id + "node";
          $(id).css("fill", "pink");
          drawVisiting(p, alignment, range);
        }

        if (p.isleaf) {
          // leaf node, so just report it to solve an important bug
          // if alignment, comparing to x
          if (alignment) {
            if (smaller <= p.val[0] && bigger >= p.val[0]) {
              if (draw) {
                drawS(p, alignment, range);
                await timer(1000);
              }

              return p;
            } else {
              if (draw) {
                await timer(1000);
                drawNotFindSplit();
              }
              return null;
            }
          } else {
            // not alignment, comparing to y
            if (smaller <= p.val[1] && bigger >= p.val[1]) {
              if (draw) {
                drawS(p, alignment, range);
                await timer(1000);
              }

              return p;
            } else {
              if (draw) {
                drawNotFindSplit();
                await timer(1000);
              }
              return null;
            }
          }
        } else {
          // the bigger >= p.val is necessary here (equal sign is necessary)
          // to deal with degeneracy
          if (smaller <= p.val && bigger >= p.val) {
            if (draw) {
              drawS(p, alignment, range);
              await timer(1000);
            }
            return p;
          } else {
            if (draw) {
              await timer(1000);
            }
            if (bigger <= p.val) {
              p = p.left;
            } else {
              p = p.right;
            }
          }
        }
      }
      drawNotFindSplit();
      return null;
    }

    // check if a point is within range or not
    async function withinRange(point, range, node, draw = true) {
      var x = point[0];
      var y = point[1];
      var messageNumber = numMessage++;
      var text =
        "Step" +
        messageNumber +
        ". Checking if node: " +
        (node.val[0] + "," + node.val[1]) +
        " is it within query constraints?...";
      if (
        x >= range.xleft &&
        x <= range.xright &&
        y >= range.ybottom &&
        y <= range.ytop
      ) {
        if (draw) {
          treeSVG
            .append("text")
            .attr("dx", node.x - 10)
            .attr("dy", node.y + 10)
            .text("WR")
            .style("fill", "orange");
          var id = "." + node.id + "node";
          $(id)
            .not("." + node.id + "explain")
            .css("fill", "orange");
          text += "[YES~!]";
          treeSVG
            .append("text")
            .attr("class", node.id + "node " + node.id + "explain")
            .attr("dx", startingMessageX)
            .attr("dy", startingMessageY + messageNumber * messageRange)
            .text(text)
            .on("mouseover", function (dp) {
              var id = "." + d3.select(this).attr("class").split(" ")[0];
              $(id).attr("r", "10");
            })
            .on("mouseout", function (dp) {
              var id = "." + d3.select(this).attr("class").split(" ")[0];
              $(id).attr("r", "5");
            })
            .style("fill", "#fdfdfd");
          await timer(1000);
        }
        return true;
      }
      text += "[NO!!]";
      treeSVG
        .append("text")
        .attr("class", node.id + "node " + node.id + "explain")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "5");
        })
        .style("fill", "#fdfdfd");
      return false;
    }

    // report the entire subtree
    async function reportSubtreeNode(node, draw) {
      if (node === null) {
        return [];
      }
      if (draw) {
        treeSVG
          .append("text")
          .attr("dx", node.x - 10)
          .attr("dy", node.y + 10)
          .text("RS")
          .style("fill", "lightgreen");
        var id = "." + node.id + "node";
        $(id).css("fill", "lightgreen");
        drawReportSubtreeVisit(node);
        await timer(1000);
      }

      var p = node;
      var stack = [];
      stack.push(p);
      var result = [];
      while (stack.length !== 0) {
        var n = stack.pop();
        if (!n.isleaf) {
          if (n.left !== null) {
            stack.push(n.left);
          }
          if (n.right !== null) {
            n.right && stack.push(n.right);
          }
        } else {
          result.push(n.val);
        }
      }
      return result;
    }

    function drawReportSubtreeVisit(node) {
      var messageNumber = numMessage++;
      var text =
        "Step " +
        messageNumber.toString() +
        ". Report entire subtree of node: " +
        (node.isleaf ? node.val[0] + "," + node.val[1] : node.val) +
        ". All constraints satisfied";
      treeSVG
        .append("text")
        .attr("class", node.id + "node " + node.id + "explain")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "5");
        })
        .style("fill", "#fdfdfd");
    }

    function drawOneDRangeSearchVisit(node) {
      var messageNumber = numMessage++;
      var text =
        "Step " +
        messageNumber.toString() +
        ". OneD Range Searching Node: " +
        (node.isleaf ? node.val[0] + "," + node.val[1] : node.val) +
        ". All its subtrees satisfy horizontal constraints";
      treeSVG
        .append("text")
        .attr("class", node.id + "node " + node.id + "explain")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "5");
        })
        .style("fill", "#fdfdfd");
    }

    // range search on the y axis
    async function oneDRangeSearch(node, range, draw) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      // console.log("oneDRangeSearch");
      if (draw) {
        var id = "." + node.id + "node";
        $(id).css("fill", "lightblue");
        drawOneDRangeSearchVisit(node);
        await timer(1000);
      }

      if (node.isleaf) {
        if (await withinRange(node.val, range, node, draw)) {
          return [node.val];
        }
        return [];
      }
      var vsplit = await findSplitNode(node.assoc, range, false, draw);
      // console.log("oneDRange Split Node", vsplit);
      if (vsplit === null) {
        return [];
      }

      if (vsplit.isleaf) {
        if (await withinRange(vsplit.val, range, vsplit, draw)) {
          return [vsplit.val];
        } else {
          return [];
        }
      } else {
        var vl = vsplit.left;
        var resultingData = [];
        while (!vl.isleaf) {
          if (draw) {
            var id = "." + vl.id + "node";
            $(id).css("fill", "pink");
            drawTwoDRangeVisit(vl, range);
            await timer(1000);
          }

          if (yb <= vl.val) {
            resultingData = resultingData.concat(
              await reportSubtreeNode(vl.right, draw)
            );
            vl = vl.left;
          } else {
            vl = vl.right;
          }
        }
        if (draw) {
          var id = "." + vl.id + "node";
          $(id).css("fill", "pink");
          drawTwoDRangeVisit(vl, range);
          await timer(1000);
        }

        if (await withinRange(vl.val, range, vl, draw)) {
          resultingData.push(vl.val);
        }
        var vr = vsplit.right;
        while (!vr.isleaf) {
          if (draw) {
            var id = "." + vr.id + "node";
            $(id).css("fill", "pink");
            drawTwoDRangeVisit(vr, range);
            await timer(1000);
          }

          if (yt >= vr.val) {
            resultingData = resultingData.concat(
              await reportSubtreeNode(vr.left, draw)
            );
            vr = vr.right;
          } else {
            vr = vr.left;
          }
        }
        if (draw) {
          var id = "." + vr.id + "node";
          $(id).css("fill", "pink");
          drawTwoDRangeVisit(vr, range);
          await timer(1000);
        }

        if (await withinRange(vr.val, range, vr, draw)) {
          resultingData.push(vr.val);
        }
        return resultingData;
      }
    }

    function drawTwoDRangeVisit(node, range) {
      var messageNumber = numMessage++;
      var text =
        "Step " +
        messageNumber.toString() +
        ". Visiting " +
        (node.isleaf ? node.val[0] + "," + node.val[1] : node.val);
      treeSVG
        .append("text")
        .attr("class", node.id + "node " + node.id + "explain")
        .attr("dx", startingMessageX)
        .attr("dy", startingMessageY + messageNumber * messageRange)
        .text(text)
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "10");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("class").split(" ")[0];
          $(id).attr("r", "5");
        })
        .style("fill", "#fdfdfd");
    }

    async function twoDRangeSearch(node, range, draw = true) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var vsplit = await findSplitNode(node, range, true, draw);

      // console.log("twoDSplitNode", vsplit);
      if (vsplit === null) {
        return [];
      }
      if (vsplit.isleaf) {
        if (await withinRange(vsplit.val, range, vsplit, draw)) {
          return [vsplit.val];
        } else {
          return [];
        }
      } else {
        var vl = vsplit.left;
        var resultingData = [];
        while (!vl.isleaf) {
          if (draw) {
            var id = "." + vl.id + "node";
            $(id).css("fill", "pink");
            drawTwoDRangeVisit(vl, range);
            await timer(1000);
          }

          if (xl <= vl.val) {
            // console.log("xl <= vl.val, searching vl.right.assoc");
            resultingData = resultingData.concat(
              await oneDRangeSearch(vl.right, range, draw)
            );
            vl = vl.left;
          } else {
            vl = vl.right;
          }
        }

        if (draw) {
          var id = "." + vl.id + "node";
          $(id).css("fill", "pink");
          drawTwoDRangeVisit(vl, range);
          await timer(1000);
        }

        if (await withinRange(vl.val, range, vl, draw)) {
          resultingData.push(vl.val);
        }
        var vr = vsplit.right;
        while (!vr.isleaf) {
          if (draw) {
            var id = "." + vr.id + "node";
            $(id).css("fill", "pink");
            drawTwoDRangeVisit(vr, range);
            await timer(1000);
          }

          if (xr >= vr.val) {
            // console.log("xr > vl.val, searching vr.left.assoc");
            resultingData = resultingData.concat(
              await oneDRangeSearch(vr.left, range, draw)
            );
            vr = vr.right;
          } else {
            vr = vr.left;
          }
        }
        if (draw) {
          var id = "." + vr.id + "node";
          $(id).css("fill", "pink");
          drawTwoDRangeVisit(vr, range);
          await timer(1000);
        }

        if (await withinRange(vr.val, range, vr, draw)) {
          resultingData.push(vr.val);
        }
        return resultingData;
      }
    }
    var tree = null;
    function randomizedQuery() {
      var randomizedRange = getRandomRange();
      updateUserInput(
        randomizedRange.xleft,
        randomizedRange.ybottom,
        randomizedRange.xright - randomizedRange.xleft,
        randomizedRange.ytop - randomizedRange.ybottom
      );
      refreshSvg();
    }
    function randomized() {
      points = getRandomPoints(8);
      for (let i = 0; i < points.length; i++) {
        if (dps.length < 16) {
          addPointToPlane(points[i][0], points[i][1]);
        } else {
          alert("for better display, at most 16 points are allowed.");
          break;
        }
      }
      refreshSvg();
      document.getElementById("buildTree").disabled = false;
    }

    async function buildTree() {
      document.getElementById("buildTree").disabled = true;
      refreshSvg();
      refreshTree();
      for (let j = 0; j < dps.length; j++) {
        dps[j][2] = "#2f2f2f";
      }
      var copydps = [];
      for (let j = 0; j < dps.length; j++) {
        copydps.push([dps[j][0], dps[j][1], dps[j][2]]);
      }
      tree = build2DRangeTree(copydps);
      console.log(tree);
      await drawPoints(tree);
      document.getElementById("findPoints").disabled = false;
      document.getElementById("buildTree").disabled = false;
    }
    // find points
    async function findPoints() {
      // reinitializing
      document.getElementById("buildTree").disabled = true;
      document.getElementById("findPoints").disabled = true;
      document.getElementById("randomizedPoint").disabled = true;
      document.getElementById("randomizedQuery").disabled = true;
      // range
      refreshSvg();
      var range = userInputRange;
      var inRangeData = await twoDRangeSearch(tree, range);

      for (let i = 0; i < inRangeData.length; i++) {
        const inRange = inRangeData[i];
        for (let j = 0; j < dps.length; j++) {
          const actualData = dps[j];
          if (inRange[0] == actualData[0] && inRange[1] === actualData[1]) {
            dps[j][2] = "red";
          }
        }
      }
      refreshSvg();
      document.getElementById("buildTree").disabled = false;
      document.getElementById("randomizedPoint").disabled = false;
      document.getElementById("randomizedQuery").disabled = false;
    }

    var treeData = [];
    function drawTreeNode() {
      var dots = treeSVG.selectAll("g").data(treeData).enter().append("g");
      dots
        .append("circle")
        .attr("class", function (dp) {
          if (dp[0].leafID) {
            return (
              dp[0].id.toString() +
              "node hovercursor " +
              dp[0].leafID.toString() +
              "leaf"
            );
          }
          return dp[0].id.toString() + "node hovercursor";
        })
        .on("mouseover", function (dp) {
          var classes = d3.select(this).attr("class").split(" ");
          var id = "";
          if (classes.length === 3) {
            id = "." + classes[2];
            $(id).attr("r", "10");
          }
          id = "." + classes[0];
          var explainer = id + "." + id.match(/\d+/) + "explain";
          $(explainer).css("fill", d3.select(this).style("fill"));
        })
        .on("mouseout", function (dp) {
          var classes = d3.select(this).attr("class").split(" ");
          var id = "";
          if (classes.length === 3) {
            id = "." + classes[2];
            $(id).attr("r", "5");
          }
          id = "." + classes[0];
          var explainer = id + "." + id.match(/\d+/) + "explain";
          $(explainer).css("fill", "#fdfdfd");
        })
        .attr("cx", function (dp) {
          return dp[0].x;
        })
        .attr("cy", function (dp) {
          return dp[0].y;
        })
        .attr("r", 5)
        .style("fill", function (dp) {
          return dp[1];
        });
      dots
        .append("text")
        .attr("class", function (dp) {
          if (dp[0].leafID) {
            return (
              dp[0].id.toString() +
              "node hovercursor " +
              dp[0].leafID.toString() +
              "leaf"
            );
          }
          return dp[0].id.toString() + "node hovercursor";
        })
        .on("mouseover", function (dp) {
          var classes = d3.select(this).attr("class").split(" ");
          var id = "";
          if (classes.length === 3) {
            id = "." + classes[2];
            $(id).attr("r", "10");
          }
          id = "." + classes[0];
          var explainer = id + "." + id.match(/\d+/) + "explain";
          $(explainer).css("fill", d3.select(this).style("fill"));
        })
        .on("mouseout", function (dp) {
          var classes = d3.select(this).attr("class").split(" ");
          var id = "";
          if (classes.length === 3) {
            id = "." + classes[2];
            $(id).attr("r", "5");
          }
          id = "." + classes[0];
          var explainer = id + "." + id.match(/\d+/) + "explain";
          $(explainer).css("fill", "#fdfdfd");
        })
        .attr("dx", function (dp) {
          return dp[0].x + 10;
        })
        .attr("dy", function (dp) {
          return dp[0].y + 5;
        })
        .text(function (dp) {
          if (Array.isArray(dp[0].val)) {
            return dp[0].val.slice(0, 2).toString();
          } else {
            return dp[0].val;
          }
        })
        .style("fill", "#fdfdfd");
    }
    var treeBranch = [];
    function drawTreeBranch() {
      var branches = treeSVG.selectAll("line").data(treeBranch).enter();
      branches
        .append("line")
        .style("stroke", "#fdfdfd80")
        .style("stroke-width", 3)
        .attr("x1", function (dp) {
          return dp[0];
        })
        .attr("y1", function (dp) {
          return dp[1] - 1;
        })
        .attr("x2", function (dp) {
          return dp[2];
        })
        .attr("y2", function (dp) {
          return dp[3] + 1;
        });
    }
    const timer = (ms) => new Promise((res) => setTimeout(res, ms));

    // draw the assoc tree
    // logic is the same
    // we would init the node at different positions though,
    // so we need to pass that information in,
    // use the node's position as the init position
    async function drawAssocTree(node, initX, initY, maxlevel) {
      if (node === null) {
        return;
      }
      var p = node;
      var stack = [];
      var levelRange = 50;
      var nodeRange = 15;
      var initNodeRange = nodeRange * 2 ** maxlevel;
      // node, level, left/right, x
      stack.push([p, 0, 0, initY]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        var childposition = info[2];
        var yposition = info[3];
        n.y = yposition;
        n.x = initX + level * levelRange;
        if (!n.isleaf) {
          if (n.left) {
            stack.splice(0, 0, [
              n.left,
              level + 1,
              -1,
              yposition + initNodeRange / 2 ** (level + 1),
            ]);
            // node, level, x, y
            // x and y can be calculated from level: x = nodeRange * (2 ** (level + 1)), y += level * levelRange;
          }
          if (n.right) {
            stack.splice(0, 0, [
              n.right,
              level + 1,
              1,
              yposition - initNodeRange / 2 ** (level + 1),
            ]);
          }
        }
        if (n.parent) {
          treeBranch.push([n.x, n.y, n.parent.x, n.parent.y]);
        }
        drawTreeBranch();
        treeData.push([n, "#fdfdfd"]);
        drawTreeNode();

        await timer(1);
      }
    }

    async function drawPoints(node) {
      if (node === null) {
        return;
      }
      var p = node;
      var stack = [];
      var initX = $("#tree").width() / 2 - 20;
      var initY = 280;
      var levelRange = 250;
      var nodeRange = 52;
      var maxlevel = 0;

      // find maxLevel
      stack.push([p, 0]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        if (level > maxlevel) {
          maxlevel = level;
        }
        if (!n.isleaf) {
          if (n.left) {
            stack.push([n.left, level + 1]);
          }
          if (n.right) {
            stack.push([n.right, level + 1]);
          }
        }
      }

      var initNodeRange = nodeRange * 2 ** maxlevel;
      // node, level, 0/-1/1 -> root/left/right, x position
      p = node;
      stack.push([p, 0, 0, initX]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        var childposition = info[2];
        var xposition = info[3];
        n.x = xposition;
        n.y = initY + level * (levelRange - level * 25);
        if (!n.isleaf) {
          if (n.left) {
            stack.splice(0, 0, [
              n.left,
              level + 1,
              -1,
              xposition - initNodeRange / 2 ** (level + 1),
            ]);
            // node, level, x, y
            // x and y can be calculated from level: x = nodeRange * (2 ** (level + 1)), y += level * levelRange;
          }
          if (n.right) {
            stack.splice(0, 0, [
              n.right,
              level + 1,
              1,
              xposition + initNodeRange / 2 ** (level + 1),
            ]);
          }
        }
        if (n.parent) {
          treeBranch.push([n.x, n.y, n.parent.x, n.parent.y]);
        }
        drawTreeBranch();
        treeData.push([n, "#fdfdfd"]);
        drawTreeNode();
        if (!n.isleaf) {
          await drawAssocTree(n.assoc, n.x + 60, n.y, maxlevel - level);
        }
        await timer(1);
      }
    }

    // testing
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
    }
    function getRandomRange() {
      var w = $("#plane").width();
      var h = $("#plane").height();
      var xl = getRandomInt(0, w);
      var xr = getRandomInt(0, w);
      var yt = getRandomInt(0, h);
      var yb = getRandomInt(0, h);
      var range = {
        xleft: Math.min(xl, xr),
        xright: Math.max(xl, xr),
        ytop: Math.max(yt, yb),
        ybottom: Math.min(yt, yb),
      };
      return range;
    }
    function getRandomPoints(n) {
      var points = [];
      var w = $("#plane").width() - 50;
      var h = $("#plane").height() - 50;
      for (let index = 0; index < n; index++) {
        points.push([getRandomInt(50, w), getRandomInt(50, h)]);
      }
      return points;
    }

    async function testRangeSearch(n) {
      // randomly generate 100 points
      // randomly choose four values as the range
      // do a search, and do a n^2 search
      // compare the result
      var points = getRandomPoints(n);
      var range = getRandomRange();
      var tree = build2DRangeTree(points);
      var inRangeData = await twoDRangeSearch(tree, range, false);
      var validation = [];
      for (let index = 0; index < points.length; index++) {
        const element = points[index];
        if (await withinRange(element, range, null, false)) {
          validation.push(element);
        }
      }
      for (let index = 0; index < validation.length; index++) {
        const element = validation[index];
        var found = false;
        for (let j = 0; j < inRangeData.length; j++) {
          const algoFound = inRangeData[j];
          if (algoFound[0] == element[0] && algoFound[1] == element[1]) {
            found = true;
            break;
          }
        }
        if (found === false) {
          console.log(range);
          console.log(points);
          console.log(tree);
          console.log(inRangeData);
          console.log(validation);
          console.log("couldnot find sth");
          return false;
        }
      }
      return inRangeData.length === validation.length ? true : false;
    }

    // n, number of tests
    // m, number of points per test
    async function multiTest(n, m) {
      console.log(
        "running testing for ",
        n,
        "iterations with ",
        m,
        "test points"
      );
      var successCount = 0;
      var failureCount = 0;
      for (let index = 0; index < n; index++) {
        result = await testRangeSearch(m);
        result ? (successCount += 1) : (failureCount += 1);
      }
      console.log("success rate:", successCount, "/", n);
    }
  </script>
</html>
