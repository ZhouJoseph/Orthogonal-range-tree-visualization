<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orthogonal Rnage Tree Demo</title>
    <!-- d3.js for data visualization purposes -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- bootstrap CSS-->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css"
    />
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <!-- Add a svg shape -->
    <section class="hero is-light">
      <div class="hero-body">
        <div>
          <p class="is-size-4"><b>What is this?</b></p>
          <p class="is-size-6">
            It's my personal project:
            <b>2D Orthogonal Range Tree Visualization</b>. <br />
            - <b><i>The left canvas:</i></b> is the <b>plane</b> canvas which
            holds the points that we are working with.
            <br />
            - <b><i>The right canvas:</i></b> displays the orthogonal range tree
            generataed from the points in the left canvas.
          </p>
          <br />
          <p class="is-size-4"><b>How to use it?</b></p>
          <p class="is-size-6">
            <b>1. point inialization:</b><br />
            - You can enter your own points by clicking on the left canvas.
            <br />
            - Or you can initialize them randomly by clicking the [random points
            generation] button. <br />
            <b>2. range tree creation:</b><br />
            - Once you create your points, you can click the [Build Range Tree]
            button <br />
            <b>3. search:</b><br />
            - Once you built your range tree, you can click the [Find Points in
            Range] button
          </p>
        </div>
      </div>
    </section>
    <div id="workdiv">
      <div id="planediv">
        <center>
          <div class="container">
            <p class="is-size-4">Plane canvas</p>
          </div>
        </center>
        <div id="svgWrapper">
          <svg id="plane"></svg>
          <fieldset id="controls">
            <label>x:<input type="text" id="x" value="150" /></label>
            <label>y:<input type="text" id="y" value="150" /></label>
            <label>width:<input type="text" id="width" value="400" /></label>
            <label>height:<input type="text" id="height" value="400" /></label>
          </fieldset>
        </div>
        <button
          id="buildTree"
          class="button is-info is-light"
          onclick="buildTree()"
          disabled
        >
          Build Range Tree
        </button>
        <button
          id="findPoints"
          class="button is-info is-light"
          onclick="findPoints()"
          disabled
        >
          Find Points in Range
        </button>
        <button
          id="findPoints"
          class="button is-info is-light"
          onclick="randomized()"
        >
          Randomized 8 Points and Query Range
        </button>
      </div>
      <div id="treediv">
        <center>
          <div class="container">
            <p class="is-size-4">Tree Canvas</p>
          </div>
        </center>
        <svg id="tree"></svg>
      </div>
    </div>
    <!-- bootstrap js -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
      crossorigin="anonymous"
    ></script>

    <script
      src="https://code.jquery.com/jquery-3.6.0.slim.js"
      integrity="sha256-HwWONEZrpuoh951cQD1ov2HUK5zA5DwJ1DNUXaM6FsY="
      crossorigin="anonymous"
    ></script>
  </body>
  <script>
    // setup & initilize
    var userInputRange = {};
    var inpX = document.getElementById("x");
    var inpY = document.getElementById("y");
    var inpWidth = document.getElementById("width");
    var inpHeight = document.getElementById("height");

    [inpX, inpY, inpWidth, inpHeight].forEach(function (e) {
      e.addEventListener("change", updateUserInputRange);
    });

    var planeSVG = d3.select("#plane");
    var treeSVG = d3.select("#tree");

    function updateUserInputRange() {
      userInputRange = {
        xleft: parseFloat(inpX.value),
        xright: parseFloat(inpX.value) + parseFloat(inpWidth.value),
        ytop: parseFloat(inpY.value) + parseFloat(inpHeight.value),
        ybottom: parseFloat(inpY.value),
      };
      planeSVG.selectAll("rect").remove();
      planeSVG
        .append("rect")
        .attr("x", parseFloat(inpX.value))
        .attr("y", parseFloat(inpY.value))
        .attr("width", parseFloat(inpWidth.value))
        .attr("height", parseFloat(inpHeight.value))
        .attr("stroke", "#2f2f2f")
        .attr("fill", "#ffffff50");
    }
    var planeWidth = $("#plane").width();
    var planeHeight = $("#plane").height();
    var rangeWidth = 200;
    function updateUserInput(x, y, width, height) {
      $("#x").val(x.toString());
      $("#y").val(y.toString());
      $("#width").val(width.toString());
      $("#height").val(height.toString());
    }
    updateUserInput(
      planeWidth / 2 - rangeWidth / 2,
      planeHeight / 2 - rangeWidth / 2,
      rangeWidth,
      rangeWidth
    );
    updateUserInputRange();

    // points are stored in dps -> data points;
    var dps = [];
    // to refresh the color of the points (to notify that point is in range, it's highlighted)
    function refreshSvg() {
      var temp = [];
      planeSVG.selectAll("g").data(temp).exit().remove();
      addPointToPlane(0, 0, false);
    }
    // to refresh the tree (exit and then remove)
    function refreshTree() {
      treeData = [];
      treeBranch = [];
      treeSVG.selectAll("text").data([]).exit().remove();
      treeSVG.selectAll("g").data(treeData).exit().remove();
      treeSVG.selectAll("line").data(treeBranch).exit().remove();
    }

    function addPointToPlane(x, y, push = true) {
      if (push) {
        console.log("clicked:", x, y);

        if (dps.length != 0) {
          document.getElementById("buildTree").disabled = false;
        }
        // var leafkey = x + ";" + y;
        // var id = 0;
        // if (leafkey in leafNodeID) {
        //   id = leafNodeID[leafkey];
        // } else {
        //   id = treeNodeID++;
        //   leafNodeID[leafkey] = id;
        // }
        // dps.push([x, y, "#2f2f2f", id + "node"]);
        dps.push([x, y, "#2f2f2f", -1 + "node"]);
      }

      var dots = planeSVG.selectAll("g").data(dps).enter().append("g");

      dots
        .append("circle")
        // .attr("data-class", function (dp) {
        //   return dp[3];
        // })
        // .on("mouseover", function (dp) {
        //   var id = "." + d3.select(this).attr("data-class");
        //   $(id).css("fill", "pink");
        // })
        // .on("mouseout", function (dp) {
        //   var id = "." + d3.select(this).attr("data-class");
        //   $(id).css("fill", "#fdfdfd");
        // })
        .attr("cx", function (dp) {
          return dp[0];
        })
        .attr("cy", function (dp) {
          return dp[1];
        })
        .attr("r", 3)
        .style("fill", function (dp) {
          return dp[2];
        });
      dots
        .append("text")
        .attr("data-class", function (dp) {
          return dp[3];
        })
        .on("mouseover", function (dp) {
          var id = "." + d3.select(this).attr("data-class");
          $(id).css("fill", "pink");
        })
        .on("mouseout", function (dp) {
          var id = "." + d3.select(this).attr("data-class");
          $(id).css("fill", "#fdfdfd");
        })
        .attr("dx", function (dp) {
          return dp[0];
        })
        .attr("dy", function (dp) {
          return dp[1];
        })
        .text(function (dp) {
          return dp[0].toString() + "," + dp[1].toString();
        })
        .style("fill", function (dp) {
          return dp[2];
        });
    }

    // store the clicked points
    planeSVG.on("click", function (e) {
      if (dps.length >= 16) {
        alert("for better display, at most16 points are allowed.");
        return;
      }
      var position = d3.pointer(e);
      var x = position[0];
      var y = position[1];
      addPointToPlane(x, y);
    });

    var leafNodeID = {};
    var treeNodeID = 0;
    // followed are the rangeTree Algorithm
    function createNode(
      isleaf,
      val,
      left = null,
      right = null,
      assoc = null,
      parent = null,
      x = null,
      y = null
    ) {
      // var id = -1;
      // if (isleaf) {
      //   var leafkey = val[0] + ";" + val[1];
      //   if (leafkey in leafNodeID) {
      //     id = leafNodeID[leafkey];
      //   } else {
      //     id = treeNodeID++;
      //     leafNodeID[leafkey] = id;
      //   }
      // } else {
      //   id = treeNodeID++;
      // }
      return {
        val: val,
        left: left,
        right: right,
        assoc: assoc,
        isleaf: isleaf,
        parent: parent,
        id: treeNodeID++,
      };
    }

    function splitInHalf(p, alignment = true) {
      if (alignment) {
        p.sort(function (a, b) {
          return a[0] - b[0];
        });
      } else {
        p.sort(function (a, b) {
          return a[1] - b[1];
        });
      }
      var mid = Math.ceil(p.length / 2);
      var leftHalf = p.slice(0, mid);
      var rightHalf = p.slice(mid, p.length);
      var result = {
        mid: mid - 1,
        leftHalf: leftHalf,
        rightHalf: rightHalf,
      };
      return result;
    }

    function build2DRangeTree(p, alignment = true, parent = null) {
      if (p.length === 1) {
        var node = createNode(true, p[0]);
        node.parent = parent;
        return node;
      } else {
        var result = splitInHalf(p, alignment);
        var node = createNode(
          false,
          alignment ? p[result.mid][0] : p[result.mid][1]
        );
        var leftNode = build2DRangeTree(result.leftHalf, alignment, node);
        var rightNode = build2DRangeTree(result.rightHalf, alignment, node);
        node.left = leftNode;
        node.right = rightNode;
        node.assoc = alignment ? build2DRangeTree(p, false) : null;
        node.parent = parent;
        return node;
      }
    }

    // due to degeneracy, split node needs to be more generous
    async function findSplitNode(node, range, alignment = true) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var p = node;
      var smaller = 0;
      var bigger = 0;
      if (alignment) {
        smaller = xl;
        bigger = xr;
      } else {
        smaller = yb;
        bigger = yt;
      }
      while (p !== null) {
        var id = "." + p.id + "node";
        $(id).css("fill", "lightblue");

        if (p.isleaf) {
          // leaf node, so just report it to solve an important bug
          if (alignment) {
            if (smaller <= p.val[0] && bigger >= p.val[0]) {
              treeSVG
                .append("text")
                .attr("dx", p.x - 5)
                .attr("dy", p.y - 10)
                .text("S")
                .style("fill", "lightblue");
              await timer(1000);
              return p;
            } else {
              return null;
            }
          } else {
            if (smaller <= p.val[1] && bigger >= p.val[1]) {
              treeSVG
                .append("text")
                .attr("dx", p.x - 5)
                .attr("dy", p.y - 10)
                .text("S")
                .style("fill", "lightblue");
              await timer(1000);
              return p;
            } else {
              return null;
            }
          }
        } else {
          // the bigger >= p.val is necessary here (equal sign is necessary)
          // to deal with degeneracy
          if (smaller <= p.val && bigger >= p.val) {
            treeSVG
              .append("text")
              .attr("dx", p.x - 5)
              .attr("dy", p.y - 10)
              .text("S")
              .style("fill", "lightblue");
            await timer(1000);
            return p;
          } else {
            if (bigger <= p.val) {
              p = p.left;
            } else {
              p = p.right;
            }
          }
        }
      }
      return null;
    }

    // check if a point is within range or not
    async function withinRange(point, range, node) {
      var x = point[0];
      var y = point[1];
      if (
        x >= range.xleft &&
        x <= range.xright &&
        y >= range.ybottom &&
        y <= range.ytop
      ) {
        treeSVG
          .append("text")
          .attr("dx", node.x - 10)
          .attr("dy", node.y + 10)
          .text("WR")
          .style("fill", "orange");
        await timer(1000);
        return true;
      }
      return false;
    }

    // report the entire subtree
    async function reportSubtreeNode(node) {
      if (node === null) {
        return [];
      }
      console.log("hello");
      treeSVG
        .append("text")
        .attr("dx", node.x - 10)
        .attr("dy", node.y + 10)
        .text("RS")
        .style("fill", "lightgreen");
      await timer(1000);
      var p = node;
      var stack = [];
      stack.push(p);
      var result = [];
      while (stack.length !== 0) {
        var n = stack.pop();
        if (!n.isleaf) {
          if (n.left !== null) {
            stack.push(n.left);
          }
          if (n.right !== null) {
            n.right && stack.push(n.right);
          }
        } else {
          result.push(n.val);
        }
      }
      return result;
    }

    // range search on the y axis
    async function oneDRangeSearch(node, range) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      // console.log("oneDRangeSearch");
      var id = "." + node.id + "node";
      $(id).css("fill", "purple");
      await timer(1000);
      if (node.isleaf) {
        if (await withinRange(node.val, range, node)) {
          return [node.val];
        }
        return [];
      }
      var vsplit = await findSplitNode(node.assoc, range, false);
      // console.log("oneDRange Split Node", vsplit);
      if (vsplit === null) {
        return [];
      }

      if (vsplit.isleaf) {
        if (await withinRange(vsplit.val, range, vsplit)) {
          return [vsplit.val];
        } else {
          return [];
        }
      } else {
        var vl = vsplit.left;
        var resultingData = [];
        while (!vl.isleaf) {
          var id = "." + vl.id + "node";
          $(id).css("fill", "lightblue");
          await timer(1000);
          if (yb <= vl.val) {
            resultingData = resultingData.concat(
              await reportSubtreeNode(vl.right)
            );
            vl = vl.left;
          } else {
            vl = vl.right;
          }
        }
        var id = "." + vl.id + "node";
        $(id).css("fill", "lightblue");
        await timer(1000);
        if (await withinRange(vl.val, range, vl)) {
          resultingData.push(vl.val);
        }
        var vr = vsplit.right;
        while (!vr.isleaf) {
          var id = "." + vr.id + "node";
          $(id).css("fill", "purple");
          await timer(1000);
          if (yt >= vr.val) {
            resultingData = resultingData.concat(
              await reportSubtreeNode(vr.left)
            );
            vr = vr.right;
          } else {
            vr = vr.left;
          }
        }
        var id = "." + vr.id + "node";
        $(id).css("fill", "lightblue");
        await timer(1000);
        if (await withinRange(vr.val, range, vr)) {
          resultingData.push(vr.val);
        }
        return resultingData;
      }
    }

    async function twoDRangeSearch(node, range) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var vsplit = await findSplitNode(node, range);

      // console.log("twoDSplitNode", vsplit);
      if (vsplit === null) {
        return [];
      }
      if (vsplit.isleaf) {
        if (await withinRange(vsplit.val, range, vsplit)) {
          return [vsplit.val];
        } else {
          return [];
        }
      } else {
        var vl = vsplit.left;
        var resultingData = [];
        while (!vl.isleaf) {
          var id = "." + vl.id + "node";
          $(id).css("fill", "lightblue");
          await timer(1000);
          if (xl <= vl.val) {
            // console.log("xl <= vl.val, searching vl.right.assoc");
            resultingData = resultingData.concat(
              await oneDRangeSearch(vl.right, range)
            );
            vl = vl.left;
          } else {
            vl = vl.right;
          }
        }
        var id = "." + vl.id + "node";
        $(id).css("fill", "lightblue");
        await timer(1000);
        if (await withinRange(vl.val, range, vl)) {
          resultingData.push(vl.val);
        }
        var vr = vsplit.right;
        while (!vr.isleaf) {
          var id = "." + vr.id + "node";
          $(id).css("fill", "lightblue");
          await timer(1000);
          if (xr >= vr.val) {
            // console.log("xr > vl.val, searching vr.left.assoc");
            resultingData = resultingData.concat(
              await oneDRangeSearch(vr.left, range)
            );
            vr = vr.right;
          } else {
            vr = vr.left;
          }
        }
        var id = "." + vr.id + "node";
        $(id).css("fill", "lightblue");
        await timer(1000);
        if (await withinRange(vr.val, range, vr)) {
          resultingData.push(vr.val);
        }
        return resultingData;
      }
    }
    var tree = null;
    function randomized() {
      var randomizedRange = getRandomRange();
      updateUserInput(
        randomizedRange.xleft,
        randomizedRange.ybottom,
        randomizedRange.xright - randomizedRange.xleft,
        randomizedRange.ytop - randomizedRange.ybottom
      );
      updateUserInputRange();
      points = getRandomPoints(8);
      for (let i = 0; i < points.length; i++) {
        if (dps.length < 16) {
          addPointToPlane(points[i][0], points[i][1]);
        } else {
          alert("for better display, at most 16 points are allowed.");
          break;
        }
      }
      refreshSvg();
      document.getElementById("buildTree").disabled = false;
    }

    async function buildTree() {
      document.getElementById("buildTree").disabled = true;
      refreshSvg();
      refreshTree();
      for (let j = 0; j < dps.length; j++) {
        dps[j][2] = "#2f2f2f";
      }
      var copydps = [];
      for (let j = 0; j < dps.length; j++) {
        copydps.push([dps[j][0], dps[j][1], dps[j][2]]);
      }
      tree = build2DRangeTree(copydps);
      console.log(tree);
      await drawPoints(tree);

      document.getElementById("findPoints").disabled = false;
      document.getElementById("buildTree").disabled = false;
    }
    // find points
    async function findPoints() {
      // reinitializing
      document.getElementById("findPoints").disabled = true;
      // range
      updateUserInputRange();
      var range = userInputRange;
      var inRangeData = await twoDRangeSearch(tree, range);
      for (let i = 0; i < inRangeData.length; i++) {
        const inRange = inRangeData[i];
        for (let j = 0; j < dps.length; j++) {
          const actualData = dps[j];
          if (inRange[0] == actualData[0] && inRange[1] === actualData[1]) {
            dps[j][2] = "red";
          }
        }
      }
      refreshSvg();
    }

    var treeData = [];
    function drawTreeNode() {
      var dots = treeSVG.selectAll("g").data(treeData).enter().append("g");
      // dots
      //   .append("circle")
      //   .attr("class", function (dp) {
      //     return dp[0].id.toString() + "nodeassoc";
      //   })
      //   .attr("cx", function (dp) {
      //     return dp[0].x + 10;
      //   })
      //   .attr("cy", function (dp) {
      //     return dp[0].y + 10;
      //   })
      //   .attr("r", 10)
      //   .style("opacity", "0")
      //   .style("fill", function (dp) {
      //     return dp[1];
      //   });
      dots
        .append("circle")
        .attr("class", function (dp) {
          return dp[0].id.toString() + "node hovercursor";
        })
        .attr("cx", function (dp) {
          return dp[0].x;
        })
        .attr("cy", function (dp) {
          return dp[0].y;
        })
        .attr("r", 5)
        // .on("click", function (dp) {
        //   var id = "." + d3.select(this).attr("class").split(" ")[0];
        //   id += "assoc";
        //   $(id).css("opacity", "1");
        // })
        // .on("mouseover", function (dp) {
        //   var id = "." + d3.select(this).attr("class").split(" ")[0];
        //   $(id).css("fill", "pink");
        // })
        // .on("mouseout", function (dp) {
        //   var id = "." + d3.select(this).attr("class").split(" ")[0];
        //   $(id).css("fill", "#fdfdfd");
        // })
        .style("fill", function (dp) {
          return dp[1];
        });
      dots
        .append("text")
        .attr("class", function (dp) {
          return dp[0].id.toString() + "node hovercursor";
        })
        .attr("dx", function (dp) {
          return dp[0].x + 10;
        })
        .attr("dy", function (dp) {
          return dp[0].y + 5;
        })
        // .on("click", function (dp) {
        //   var id = "." + d3.select(this).attr("class").split(" ")[0];
        //   id += "assoc";
        //   $(id).css("opacity", "1");
        // })
        // .on("mouseover", function (dp) {
        //   var id = "." + d3.select(this).attr("class").split(" ")[0];
        //   $(id).css("fill", "pink");
        // })
        // .on("mouseout", function (dp) {
        //   var id = "." + d3.select(this).attr("class").split(" ")[0];
        //   $(id).css("fill", "#fdfdfd");
        // })
        .text(function (dp) {
          if (Array.isArray(dp[0].val)) {
            return dp[0].val.slice(0, 2).toString();
          } else {
            return dp[0].val;
          }
        })
        .style("fill", "#fdfdfd");
    }
    var treeBranch = [];
    function drawTreeBranch() {
      var branches = treeSVG.selectAll("line").data(treeBranch).enter();
      branches
        .append("line")
        .style("stroke", "#fdfdfd80")
        .style("stroke-width", 3)
        .attr("x1", function (dp) {
          return dp[0];
        })
        .attr("y1", function (dp) {
          return dp[1] - 1;
        })
        .attr("x2", function (dp) {
          return dp[2];
        })
        .attr("y2", function (dp) {
          return dp[3] + 1;
        });
    }
    const timer = (ms) => new Promise((res) => setTimeout(res, ms));

    // draw the assoc tree
    // logic is the same
    // we would init the node at different positions though,
    // so we need to pass that information in,
    // use the node's position as the init position
    async function drawAssocTree(node, initX, initY, maxlevel) {
      if (node === null) {
        return;
      }
      var p = node;
      var stack = [];
      var levelRange = 50;
      var nodeRange = 15;
      var initNodeRange = nodeRange * 2 ** maxlevel;
      // node, level, left/right, x
      stack.push([p, 0, 0, initY]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        var childposition = info[2];
        var yposition = info[3];
        n.y = yposition;
        n.x = initX + level * levelRange;
        if (!n.isleaf) {
          if (n.left) {
            stack.splice(0, 0, [
              n.left,
              level + 1,
              -1,
              yposition + initNodeRange / 2 ** (level + 1),
            ]);
            // node, level, x, y
            // x and y can be calculated from level: x = nodeRange * (2 ** (level + 1)), y += level * levelRange;
          }
          if (n.right) {
            stack.splice(0, 0, [
              n.right,
              level + 1,
              1,
              yposition - initNodeRange / 2 ** (level + 1),
            ]);
          }
        }
        if (n.parent) {
          treeBranch.push([n.x, n.y, n.parent.x, n.parent.y]);
        }
        drawTreeBranch();
        treeData.push([n, "#fdfdfd"]);
        drawTreeNode();

        await timer(1);
      }
    }

    async function drawPoints(node) {
      if (node === null) {
        return;
      }
      var p = node;
      var stack = [];
      var initX = $("#tree").width() / 2;
      var initY = 300;
      var levelRange = 250;
      var nodeRange = 60;
      var maxlevel = 0;

      // find maxLevel
      stack.push([p, 0]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        if (level > maxlevel) {
          maxlevel = level;
        }
        if (!n.isleaf) {
          if (n.left) {
            stack.push([n.left, level + 1]);
          }
          if (n.right) {
            stack.push([n.right, level + 1]);
          }
        }
      }

      var initNodeRange = nodeRange * 2 ** maxlevel;
      // node, level, 0/-1/1 -> root/left/right, x position
      p = node;
      stack.push([p, 0, 0, initX]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        var childposition = info[2];
        var xposition = info[3];
        n.x = xposition;
        n.y = initY + level * (levelRange - level * 25);
        if (!n.isleaf) {
          if (n.left) {
            stack.splice(0, 0, [
              n.left,
              level + 1,
              -1,
              xposition - initNodeRange / 2 ** (level + 1),
            ]);
            // node, level, x, y
            // x and y can be calculated from level: x = nodeRange * (2 ** (level + 1)), y += level * levelRange;
          }
          if (n.right) {
            stack.splice(0, 0, [
              n.right,
              level + 1,
              1,
              xposition + initNodeRange / 2 ** (level + 1),
            ]);
          }
        }
        if (n.parent) {
          treeBranch.push([n.x, n.y, n.parent.x, n.parent.y]);
        }
        drawTreeBranch();
        treeData.push([n, "#fdfdfd"]);
        drawTreeNode();
        if (!n.isleaf) {
          await drawAssocTree(n.assoc, n.x + 50, n.y, maxlevel - level);
        }
        await timer(1);
      }
    }

    // testing
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
    }
    function getRandomRange() {
      var w = $("#plane").width();
      var h = $("#plane").height();
      var xl = getRandomInt(0, w / 2);
      var xr = getRandomInt(w / 2, w);
      var yt = getRandomInt(h / 2, h);
      var yb = getRandomInt(0, h / 2);
      var range = {
        xleft: xl,
        xright: xr,
        ytop: yt,
        ybottom: yb,
      };
      return range;
    }
    function getRandomPoints(n) {
      var points = [];
      var w = $("#plane").width() - 50;
      var h = $("#plane").height() - 50;
      for (let index = 0; index < n; index++) {
        points.push([getRandomInt(50, w), getRandomInt(50, h)]);
      }
      return points;
    }
    // function testRangeSearch(n) {
    //   // randomly generate 100 points
    //   // randomly choose four values as the range
    //   // do a search, and do a n^2 search
    //   // compare the result
    //   var points = getRandomPoints(n);
    //   var range = getRandomRange();
    //   var tree = build2DRangeTree(points);
    //   var inRangeData = twoDRangeSearch(tree, range);
    //   var validation = [];
    //   for (let index = 0; index < points.length; index++) {
    //     const element = points[index];
    //     if (await withinRange(element, range)) {
    //       validation.push(element);
    //     }
    //   }
    //   for (let index = 0; index < validation.length; index++) {
    //     const element = validation[index];
    //     var found = false;
    //     for (let j = 0; j < inRangeData.length; j++) {
    //       const algoFound = inRangeData[j];
    //       if (algoFound[0] == element[0] && algoFound[1] == element[1]) {
    //         found = true;
    //         break;
    //       }
    //     }
    //     if (found === false) {
    //       console.log(range);
    //       console.log(points);
    //       console.log(tree);
    //       console.log(inRangeData);
    //       console.log(validation);
    //       console.log("couldnot find sth");
    //       return false;
    //     }
    //   }
    //   return inRangeData.length === validation.length ? true : false;
    // }

    // // n, number of tests
    // // m, number of points per test
    // function multiTest(n, m) {
    //   console.log(
    //     "running testing for ",
    //     n,
    //     "iterations with ",
    //     m,
    //     "test points"
    //   );
    //   var successCount = 0;
    //   var failureCount = 0;
    //   for (let index = 0; index < n; index++) {
    //     testRangeSearch(m) ? (successCount += 1) : (failureCount += 1);
    //   }
    //   console.log("success rate:", successCount, "/", n);
    // }
  </script>
</html>
