<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orthogonal Rnage Tree Demo</title>
    <!-- d3.js for data visualization purposes -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- bootstrap CSS-->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css"
    />
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <!-- Add a svg shape -->
    <section class="hero is-light">
      <div class="hero-body">
        <div>
          <p class="is-size-4"><b>What is this?</b></p>
          <p class="is-size-6">
            It's my personal project:
            <b>2D Orthogonal Range Tree Visualization</b>. <br />
            - <b><i>The left canvas:</i></b> is the <b>plane</b> canvas which
            holds the points that we are working with.
            <br />
            - <b><i>The right canvas:</i></b> displays the orthogonal range tree
            generataed from the points in the left canvas.
          </p>
          <br />
          <p class="is-size-4"><b>How to use it?</b></p>
          <p class="is-size-6">
            <b>1. point inialization:</b><br />
            - You can enter your own points by clicking on the left canvas.
            <br />
            - Or you can initialize them randomly by clicking the [random points
            generation] button.
          </p>
        </div>
      </div>
    </section>
    <div id="workdiv">
      <div id="planediv">
        <center>
          <div class="container">
            <p class="is-size-4">Plane canvas</p>
          </div>
        </center>
        <div id="svgWrapper">
          <svg id="plane"></svg>
          <fieldset id="controls">
            <label>x:<input type="text" id="x" value="150" /></label>
            <label>y:<input type="text" id="y" value="150" /></label>
            <label>width:<input type="text" id="width" value="400" /></label>
            <label>height:<input type="text" id="height" value="400" /></label>
          </fieldset>
        </div>
        <button
          id="buildTree"
          class="button is-info is-light"
          onclick="buildTree()"
          disabled
        >
          Build Range Tree
        </button>
        <button
          id="findPoints"
          class="button is-info is-light"
          onclick="findPoints()"
          disabled
        >
          Find Points in Range
        </button>
        <button
          id="findPoints"
          class="button is-info is-light"
          onclick="randomized()"
        >
          Randomized 8 Points and Query Range
        </button>
      </div>
      <div id="treediv">
        <center>
          <div class="container">
            <p class="is-size-4">Tree Canvas</p>
          </div>
        </center>
        <svg id="tree"></svg>
      </div>
    </div>
    <!-- bootstrap js -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
      crossorigin="anonymous"
    ></script>

    <script
      src="https://code.jquery.com/jquery-3.6.0.slim.js"
      integrity="sha256-HwWONEZrpuoh951cQD1ov2HUK5zA5DwJ1DNUXaM6FsY="
      crossorigin="anonymous"
    ></script>
  </body>
  <script>
    // setup & initilize
    var userInputRange = {};
    var inpX = document.getElementById("x");
    var inpY = document.getElementById("y");
    var inpWidth = document.getElementById("width");
    var inpHeight = document.getElementById("height");

    [inpX, inpY, inpWidth, inpHeight].forEach(function (e) {
      e.addEventListener("change", updateUserInputRange);
    });

    var planeSVG = d3.select("#plane");
    var treeSVG = d3.select("#tree");

    function updateUserInputRange() {
      userInputRange = {
        xleft: parseFloat(inpX.value),
        xright: parseFloat(inpX.value) + parseFloat(inpWidth.value),
        ytop: parseFloat(inpY.value) + parseFloat(inpHeight.value),
        ybottom: parseFloat(inpY.value),
      };
      planeSVG.selectAll("rect").remove();
      planeSVG
        .append("rect")
        .attr("x", parseFloat(inpX.value))
        .attr("y", parseFloat(inpY.value))
        .attr("width", parseFloat(inpWidth.value))
        .attr("height", parseFloat(inpHeight.value))
        .attr("stroke", "#2f2f2f")
        .attr("fill", "#ffffff50");
    }
    var planeWidth = $("#plane").width();
    var planeHeight = $("#plane").height();
    var rangeWidth = 200;
    function updateUserInput(x, y, width, height) {
      $("#x").val(x.toString());
      $("#y").val(y.toString());
      $("#width").val(width.toString());
      $("#height").val(height.toString());
    }
    updateUserInput(
      planeWidth / 2 - rangeWidth / 2,
      planeHeight / 2 - rangeWidth / 2,
      rangeWidth,
      rangeWidth
    );
    updateUserInputRange();

    // points are stored in dps -> data points;
    var dps = [];
    // to refresh the color of the points (to notify that point is in range, it's highlighted)
    function refreshSvg() {
      planeSVG
        .selectAll("circle")
        .data(dps)
        .attr("cx", function (dp) {
          return dp[0];
        })
        .attr("cy", function (dp) {
          return dp[1];
        })
        .attr("r", 3)
        .style("fill", function (dp) {
          return dp[2];
        });
    }
    // to refresh the tree (exit and then remove)
    function refreshTree() {
      treeData = [];
      treeBranch = [];
      treeSVG.selectAll("g").data(treeData).exit().remove();
      treeSVG.selectAll("line").data(treeBranch).exit().remove();
    }

    // store the clicked points
    planeSVG.on("click", function (e) {
      if (dps.length >= 16) {
        alert("for better display, at most 16 points are allowed.");
        return;
      }
      var position = d3.pointer(e);
      var x = position[0];
      var y = position[1];
      console.log("clicked:", x, y);
      dps.push([x, y, "#2f2f2f"]);
      if (dps.length != 0) {
        document.getElementById("buildTree").disabled = false;
      }
      var dots = planeSVG.selectAll("g").data(dps).enter().append("g");
      dots
        .append("circle")
        .attr("cx", function (dp) {
          return dp[0];
        })
        .attr("cy", function (dp) {
          return dp[1];
        })
        .attr("r", 3)
        .style("fill", function (dp) {
          return dp[2];
        });
      dots
        .append("text")
        .attr("dx", function (dp) {
          return dp[0];
        })
        .attr("dy", function (dp) {
          return dp[1];
        })
        .text(function (dp) {
          return dp[0].toString() + "," + dp[1].toString();
        });
    });

    // followed are the rangeTree Algorithm
    function createNode(
      isleaf,
      val,
      left = null,
      right = null,
      assoc = null,
      parent = null,
      x = null,
      y = null
    ) {
      return {
        val: val,
        left: left,
        right: right,
        assoc: assoc,
        isleaf: isleaf,
        parent: parent,
      };
    }

    function splitInHalf(p, alignment = true) {
      if (alignment) {
        p.sort(function (a, b) {
          return a[0] - b[0];
        });
      } else {
        p.sort(function (a, b) {
          return a[1] - b[1];
        });
      }
      var mid = Math.ceil(p.length / 2);
      var leftHalf = p.slice(0, mid);
      var rightHalf = p.slice(mid, p.length);
      var result = {
        mid: mid - 1,
        leftHalf: leftHalf,
        rightHalf: rightHalf,
      };
      return result;
    }

    function build2DRangeTree(p, alignment = true, parent = null) {
      if (p.length === 1) {
        var node = createNode(true, p[0]);
        node.parent = parent;
        return node;
      } else {
        var result = splitInHalf(p, alignment);
        var node = createNode(
          false,
          alignment ? p[result.mid][0] : p[result.mid][1]
        );
        var leftNode = build2DRangeTree(result.leftHalf, alignment, node);
        var rightNode = build2DRangeTree(result.rightHalf, alignment, node);
        node.left = leftNode;
        node.right = rightNode;
        node.assoc = alignment ? build2DRangeTree(p, false) : null;
        node.parent = parent;
        return node;
      }
    }

    // due to degeneracy, split node needs to be more generous
    function findSplitNode(node, range, alignment = true) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var p = node;
      var smaller = 0;
      var bigger = 0;
      if (alignment) {
        smaller = xl;
        bigger = xr;
      } else {
        smaller = yb;
        bigger = yt;
      }
      while (p !== null) {
        if (p.isleaf) {
          // leaf node, so just report it to solve an important bug
          if (alignment) {
            if (smaller <= p.val[0] && bigger >= p.val[0]) {
              return p;
            } else {
              return null;
            }
          } else {
            if (smaller <= p.val[1] && bigger >= p.val[1]) {
              return p;
            } else {
              return null;
            }
          }
        } else {
          // the bigger >= p.val is necessary here (equal sign is necessary)
          // to deal with degeneracy
          if (smaller <= p.val && bigger >= p.val) {
            return p;
          } else {
            if (bigger <= p.val) {
              p = p.left;
            } else {
              p = p.right;
            }
          }
        }
      }
      return null;
    }

    // check if a point is within range or not
    function withinRange(point, range) {
      var x = point[0];
      var y = point[1];
      if (
        x >= range.xleft &&
        x <= range.xright &&
        y >= range.ybottom &&
        y <= range.ytop
      ) {
        return true;
      }
      return false;
    }

    // report the entire subtree
    function reportSubtreeNode(node) {
      if (node === null) {
        return [];
      }
      var p = node;
      var stack = [];
      stack.push(p);
      var result = [];
      while (stack.length !== 0) {
        var n = stack.pop();
        if (!n.isleaf) {
          if (n.left !== null) {
            stack.push(n.left);
          }
          if (n.right !== null) {
            n.right && stack.push(n.right);
          }
        } else {
          result.push(n.val);
        }
      }
      return result;
    }

    // range search on the y axis
    function oneDRangeSearch(node, range) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      // console.log("oneDRangeSearch");
      if (node.isleaf) {
        if (withinRange(node.val, range)) {
          return [node.val];
        }
        return [];
      }
      var vsplit = findSplitNode(node.assoc, range, false);
      // console.log("oneDRange Split Node", vsplit);
      if (vsplit === null) {
        return [];
      }
      if (vsplit.isleaf) {
        if (withinRange(vsplit.val, range)) {
          return [vsplit.val];
        } else {
          return [];
        }
      } else {
        var vl = vsplit.left;
        var resultingData = [];
        while (!vl.isleaf) {
          if (yb <= vl.val) {
            resultingData = resultingData.concat(reportSubtreeNode(vl.right));
            vl = vl.left;
          } else {
            vl = vl.right;
          }
        }
        if (withinRange(vl.val, range)) {
          resultingData.push(vl.val);
        }
        var vr = vsplit.right;
        while (!vr.isleaf) {
          if (yt >= vr.val) {
            resultingData = resultingData.concat(reportSubtreeNode(vr.left));
            vr = vr.right;
          } else {
            vr = vr.left;
          }
        }
        if (withinRange(vr.val, range)) {
          resultingData.push(vr.val);
        }
        return resultingData;
      }
    }

    function twoDRangeSearch(node, range) {
      var xl = range.xleft;
      var xr = range.xright;
      var yb = range.ybottom;
      var yt = range.ytop;
      var vsplit = findSplitNode(node, range);
      // console.log("twoDSplitNode", vsplit);
      if (vsplit === null) {
        return [];
      }
      if (vsplit.isleaf) {
        if (withinRange(vsplit.val, range)) {
          return [vsplit.val];
        } else {
          return [];
        }
      } else {
        var vl = vsplit.left;
        var resultingData = [];
        while (!vl.isleaf) {
          if (xl <= vl.val) {
            // console.log("xl <= vl.val, searching vl.right.assoc");
            resultingData = resultingData.concat(
              oneDRangeSearch(vl.right, range)
            );
            vl = vl.left;
          } else {
            vl = vl.right;
          }
        }
        if (withinRange(vl.val, range)) {
          resultingData.push(vl.val);
        }
        var vr = vsplit.right;
        while (!vr.isleaf) {
          if (xr >= vr.val) {
            // console.log("xr > vl.val, searching vr.left.assoc");
            resultingData = resultingData.concat(
              oneDRangeSearch(vr.left, range)
            );
            vr = vr.right;
          } else {
            vr = vr.left;
          }
        }
        if (withinRange(vr.val, range)) {
          resultingData.push(vr.val);
        }
        return resultingData;
      }
    }
    var tree = null;
    function randomized() {
      var randomizedRange = getRandomRange();
      updateUserInput(
        randomizedRange.xleft,
        randomizedRange.ybottom,
        randomizedRange.xright - randomizedRange.xleft,
        randomizedRange.ytop - randomizedRange.ybottom
      );
      updateUserInputRange();
      points = getRandomPoints(8);
      for (let i = 0; i < points.length; i++) {
        if (dps.length < 16) {
          dps.push([points[i][0], points[i][1], "#2f2f2f"]);
        } else {
          alert("for better display, at most 16 points are allowed.");
          break;
        }
      }
      var dots = planeSVG.selectAll("g").data(dps).enter().append("g");
      dots
        .append("circle")
        .attr("cx", function (dp) {
          return dp[0];
        })
        .attr("cy", function (dp) {
          return dp[1];
        })
        .attr("r", 3)
        .style("fill", function (dp) {
          return dp[2];
        });
      dots
        .append("text")
        .attr("dx", function (dp) {
          return dp[0];
        })
        .attr("dy", function (dp) {
          return dp[1];
        })
        .text(function (dp) {
          return dp[0].toString() + "," + dp[1].toString();
        });
      refreshSvg();
      document.getElementById("findPoints").disabled = false;
      document.getElementById("buildTree").disabled = false;
    }
    async function buildTree() {
      document.getElementById("buildTree").disabled = true;
      refreshSvg();
      refreshTree();
      for (let j = 0; j < dps.length; j++) {
        dps[j][2] = "#2f2f2f";
      }
      var copydps = [];
      for (let j = 0; j < dps.length; j++) {
        copydps.push([dps[j][0], dps[j][1], dps[j][2]]);
      }
      tree = build2DRangeTree(copydps);
      console.log(tree);
      drawPoints(tree);
      await timer(500);
      document.getElementById("findPoints").disabled = false;
      document.getElementById("buildTree").disabled = false;
    }
    // find points
    async function findPoints() {
      // reinitializing
      document.getElementById("findPoints").disabled = true;
      // range
      updateUserInputRange();
      var range = userInputRange;
      var inRangeData = twoDRangeSearch(tree, range);
      for (let i = 0; i < inRangeData.length; i++) {
        const inRange = inRangeData[i];
        for (let j = 0; j < dps.length; j++) {
          const actualData = dps[j];
          if (inRange[0] == actualData[0] && inRange[1] === actualData[1]) {
            dps[j][2] = "red";
          }
        }
      }
      refreshSvg();
    }

    var treeData = [];
    function drawTreeNode(node) {
      treeData.push([node]);
      var dots = treeSVG.selectAll("g").data(treeData).enter().append("g");
      dots
        .append("circle")
        .attr("cx", function (dp) {
          return dp[0].x;
        })
        .attr("cy", function (dp) {
          return dp[0].y;
        })
        .attr("r", 3)
        .style("fill", function (dp) {
          return "#fdfdfd";
        });
      dots
        .append("text")
        .attr("dx", function (dp) {
          return dp[0].x + 5;
        })
        .attr("dy", function (dp) {
          return dp[0].y + 5;
        })
        .text(function (dp) {
          if (Array.isArray(dp[0].val)) {
            return dp[0].val.slice(0, 2).toString();
          } else {
            return dp[0].val;
          }
        })
        .style("fill", "#fdfdfd");
    }
    var treeBranch = [];
    function drawTreeBranch(node) {
      if (node.parent) {
        treeBranch.push([node.x, node.y, node.parent.x, node.parent.y]);
        var branches = treeSVG.selectAll("line").data(treeBranch).enter();
        branches
          .append("line")
          .style("stroke", "#fdfdfd")
          .style("stroke-width", 1)
          .attr("x1", function (dp) {
            return dp[0];
          })
          .attr("y1", function (dp) {
            return dp[1];
          })
          .attr("x2", function (dp) {
            return dp[2];
          })
          .attr("y2", function (dp) {
            return dp[3];
          });
      }
    }
    const timer = (ms) => new Promise((res) => setTimeout(res, ms));
    async function drawPoints(node) {
      if (node === null) {
        return;
      }
      var p = node;
      var stack = [];
      var initX = $("#tree").width() / 2;
      var initY = 200;
      var levelRange = 80;
      var nodeRange = 45;
      var maxlevel = 0;

      // find maxLevel
      stack.push([p, 0]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        if (level > maxlevel) {
          maxlevel = level;
        }
        if (!n.isleaf) {
          if (n.left) {
            stack.push([n.left, level + 1]);
          }
          if (n.right) {
            stack.push([n.right, level + 1]);
          }
        }
      }

      var initNodeRange = nodeRange * 2 ** maxlevel;
      // node, level, 0/-1/1 -> root/left/right, x position
      p = node;
      stack.push([p, 0, 0, initX]);
      while (stack.length !== 0) {
        var info = stack.pop();
        var n = info[0];
        var level = info[1];
        var childposition = info[2];
        var xposition = info[3];
        n.x = xposition;
        n.y = initY + level * levelRange;
        if (!n.isleaf) {
          if (n.left) {
            stack.splice(0, 0, [
              n.left,
              level + 1,
              -1,
              xposition - initNodeRange / 2 ** (level + 1),
            ]);
            // node, level, x, y
            // x and y can be calculated from level: x = nodeRange * (2 ** (level + 1)), y += level * levelRange;
          }
          if (n.right) {
            stack.splice(0, 0, [
              n.right,
              level + 1,
              1,
              xposition + initNodeRange / 2 ** (level + 1),
            ]);
          }
        }
        drawTreeBranch(n);
        drawTreeNode(n);
        await timer(100);
      }
    }

    // testing
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
    }
    function getRandomRange() {
      var w = $("#plane").width();
      var h = $("#plane").height();
      var xl = getRandomInt(0, w / 2);
      var xr = getRandomInt(w / 2, w);
      var yt = getRandomInt(h / 2, h);
      var yb = getRandomInt(0, h / 2);
      var range = {
        xleft: xl,
        xright: xr,
        ytop: yt,
        ybottom: yb,
      };
      return range;
    }
    function getRandomPoints(n) {
      var points = [];
      var w = $("#plane").width();
      var h = $("#plane").height();
      for (let index = 0; index < n; index++) {
        points.push([getRandomInt(0, w), getRandomInt(0, h)]);
      }
      return points;
    }
    function testRangeSearch(n) {
      // randomly generate 100 points
      // randomly choose four values as the range
      // do a search, and do a n^2 search
      // compare the result
      var points = getRandomPoints(n);
      var range = getRandomRange();
      var tree = build2DRangeTree(points);
      var inRangeData = twoDRangeSearch(tree, range);
      var validation = [];
      for (let index = 0; index < points.length; index++) {
        const element = points[index];
        if (withinRange(element, range)) {
          validation.push(element);
        }
      }
      for (let index = 0; index < validation.length; index++) {
        const element = validation[index];
        var found = false;
        for (let j = 0; j < inRangeData.length; j++) {
          const algoFound = inRangeData[j];
          if (algoFound[0] == element[0] && algoFound[1] == element[1]) {
            found = true;
            break;
          }
        }
        if (found === false) {
          console.log(range);
          console.log(points);
          console.log(tree);
          console.log(inRangeData);
          console.log(validation);
          console.log("couldnot find sth");
          return false;
        }
      }
      return inRangeData.length === validation.length ? true : false;
    }

    // n, number of tests
    // m, number of points per test
    function multiTest(n, m) {
      console.log(
        "running testing for ",
        n,
        "iterations with ",
        m,
        "test points"
      );
      var successCount = 0;
      var failureCount = 0;
      for (let index = 0; index < n; index++) {
        testRangeSearch(m) ? (successCount += 1) : (failureCount += 1);
      }
      console.log("success rate:", successCount, "/", n);
    }
  </script>
</html>
